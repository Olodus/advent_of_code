# Read input
input â† â€¢file.At âŠ‘ â€¢args
lines â† â€¢FLines input

# Part 1
AvgBit â† {(âŒˆ2Ã·Ëœâ‰ ğ•©)âŠ¸â‰¤Â¨+Â¨Â´'0'-ËœÂ¨Â¨ğ•©}
BinaryToDecimal â† {+Â´Ã—Ë(2âŠ¸â‹†Â¨âŒ½â†•â‰ ğ•©)â‰ğ•©}
gamma â† BinaryToDecimal AvgBit lines
epsilon â† BinaryToDecimal Â¬Â¨ AvgBit lines
â€¢Show "Answer Part 1:"
â€¢Show gamma Ã— epsilon

# Part 2
## More clear way to handle input
CharValArr â† {'0'-ËœÂ¨ğ•©}
bin_arrs â† CharValArr lines

## Takes either â‰¤ or â‰¥ and checks if sum is larger than half of length
## This results in either above or below average
#bit_criteria â† {(+Â´ğ•©)ğ•((â‰ ğ•©)Ã·2)}
oxygen_criteria â† {(+Â´ğ•©)â‰¤((â‰ ğ•©)Ã·2)}
co2_criteria â† {(+Â´ğ•©)â‰¥((â‰ ğ•©)Ã·2)}

## Now we mostly have what we need.
## I think what is needed from here is to mapping over bitindex
## with a function that (chose â†©) with matches of what comes out of the criteria function.
lsr_filter â† {
    chose â† â†•â‰ ğ•©
    criteria â† ğ•
    helper â† {(criteria ğ•©âŠÂ¨(ğ•¨âŠbit_arrs)) âŠ ğ•¨}
    choseâŠ¸helperÂ´â†•5
    choseâŠinput
}
oxygen â† oxygen_criteriaâŠ¸lsr_filter input
co2  â† co2_criteriaâŠ¸lsr_filter input

## Both final arrays should only have 1 binary number left, assert on this
!1=â‰ oxygen
!1=â‰ co2

â€¢Show "Answer Part 2:"
â€¢Show "Oxygen:"
â€¢Show BinaryToDecimal oxygen
â€¢Show "CO2:"
â€¢Show BinaryToDecimal co2
â€¢Show "Life Support Rating:"
â€¢Show (BinaryToDecimal oxygen) Ã— (BinaryToDecimal co2)

CharValArr â† {'0'-ËœÂ¨ğ•©}
bin_arrs â† CharValArr âŸ¨"00100", "11110","11011"âŸ©
chose â† â†•â‰ bin_arrs
chosenâ†choseâŠbin_arrs
bin_colsâ†âŸ¨â‰  chosen,5âŸ©â¥Šâˆ¾chosen
bit_criteriaâ†{((â‰ bin_cols)Ã·2)â‰¤(+Ëbin_cols)}
